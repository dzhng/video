rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function currentUser() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function getUser(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    // ensures that only the input list of keys are used, and no others
    function assertKeys(keys) {
      return request.resource.data.keys().toSet().hasOnly(keys.toSet());
    }

    function isNewDoc() {
      return resource == null;
    }

    function requiredStringKey(key) {
      return request.resource.data[key] is string && 
              request.resource.data[key].size() > 0;
    }

    function optionalStringKey(key) {
      return key in request.resource.data ? requiredStringKey(key) : true;
    }

    function requiredIntKey(key) {
      return request.resource.data[key] is int;
    }

    function requiredPosIntKey(key) {
      return request.resource.data[key] is int &&
              request.resoure.data[key] >= 0;
    }

    function requiredBoolKey(key) {
      return request.resource.data[key] is bool;
    }

    function requiredTimeKey(key) {
      return request.resource.data[key] is timestamp;
    }

    function requiredArrayKey(key) {
      return request.resource.data[key] is list;
    }

    function optionalArrayKey(key) {
      return key in request.resource.data ? requiredArrayKey(key) : true;
    }

    function requiredObjectKey(key) {
      return request.resource.data[key] is map;
    }

    function requiredCreatedAtKey() {
      // if it exists already in existing doc, we should not change the value
      let isServerTimestamp = request.resource.data.createdAt == request.time;
      return isNewDoc() ? isServerTimestamp : (request.resource.data.createdAt == resource.data.createdAt);
    }

    match /users/{userId} {
      allow read;

      allow update: if 
        request.auth != null && 
        request.auth.uid == userId &&
        assertKeys(['bio', 'networkId', 'createdAt']) &&
        optionalStringKey('networkId') &&
        optionalStringKey('bio') &&
        requiredCreatedAtKey();
    }

    match /networks/{networkId} {

      function currentAdmin() {
        return get(/databases/$(database)/documents/networks/$(networkId)/admins/$(request.auth.uid)).data;
      }

      allow read;

      allow update: if
        request.auth != null &&
        assertKeys(['name', 'logoURL', 'primaryColor', 'createdAt']) &&
        requiredStringKey('name') &&
        optionalStringKey('logoURL') &&
        optionalStringKey('primaryColor') &&
        requiredCreatedAtKey() &&
        // only network owners can update
        currentAdmin().role == 'owner';

      match /admins/{adminId} {
        allow read: if
          request.auth != null &&
          // make sure only users in the same network can read admin list
          exists(/database/$(database)/documents/networks/$(networkId)/users/$(request.auth.uid));

        allow write: if
          assertKeys(['role', 'createdAt']) &&
          requiredStringKey('role') &&
          requiredCreatedAtKey() &&
          // make sure only owners can create another admin
          currentAdmin().role == 'owner' &&
          // make sure this admin is also an user and belongs to same network
          getUser(adminId).networkId == networkId;
      }

      match /calls/{callId} {
        allow read;

        allow write: if 
          request.auth != null &&
          assertKeys(['name', 'participants', 'externalEmails', 'presentationId', 'noteId', 'chatId', 'transcriptId', 'createdAt']) &&
          requiredStringKey('name') &&
          // list of internal users who have access to this call
          requiredArrayKey('participants') &&
          // list of external users (in form of emails) who have access to this call
          optionalArrayKey('externalEmails') &&
          // set if have presentation attachment
          optionalStringKey('presentationId') &&
          // set if have note attachment
          optionalStringKey('noteId') &&
          // set if have chat attachment
          optionalStringKey('chatId') &&
          // set once transcrit is ready
          optionalStringKey('transcriptId') &&
          requiredCreatedAtKey() &&
          // when creating, participants should contain at least one user which is the 
          // current user. When editing, existing doc must contain current user
          (isNewDoc() ? 
            (request.resource.data.participants.size() >= 1 &&
              request.resource.data.participants.hasAny([request.auth.uid])) : 
            (resource.data.participants.hasAny([request.auth.uid])));

        match /notes/{noteId} {
          allow read;

          allow write: if
            assertKeys(['text']) &&
            requiredStringKey('text');
        }
      }

      match /presentations/{presentationId} {
        allow read;

        allow write: if
          assertKeys(['fileId']) &&
          requiredStringKey('fileId');
      }
    }

  } // match database
} // service firestore
