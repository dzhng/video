rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // FOR DATA LENGTH:
    // id should be 30
    // short text like names should be 50
    // URLs should be 280
    // short descriptions should be 280

    // ensures that only the input list of keys are used, and no others
    function assertKeys(keys) {
      return request.resource.data.keys().toSet().hasOnly(keys.toSet());
    }

    function isNewDoc() {
      return resource == null;
    }

    function requiredStringKey(key, minLen, maxLen) {
      return request.resource.data[key] is string && 
              request.resource.data[key].size() >= minLen &&
              request.resource.data[key].size() <= maxLen;
    }

    function optionalStringKey(key, maxLen) {
      return (key in request.resource.data && 
          request.resource.data[key] != null) ? 
        requiredStringKey(key, 0, maxLen) : true;
    }

    function requiredIntKey(key, min, max) {
      return request.resource.data[key] is int &&
              request.resource.data[key] >= min &&
              request.resource.data[key] <= max;
    }

    function optionalIntKey(key, min, max) {
      return key in request.resource.data ? requiredIntKey(key, min, max) : true;
    }

    function requiredBoolKey(key) {
      return request.resource.data[key] is bool;
    }

    function requiredEnumKey(key, enums) {
      let item = request.resource.data[key];
      return requiredStringKey(key, 1, 10) &&
              item in enums.toSet();
    }

    function requiredTimeKey(key) {
      return request.resource.data[key] is timestamp;
    }

    function optionalTimeKey(key) {
      return (key in request.resource.data &&
          request.resource.data[key] != null) ? 
        requiredTimeKey(key) : true;
    }

    function requiredArrayKey(key, minLen, maxLen) {
      return request.resource.data[key] is list &&
              request.resource.data[key].size() <= maxLen &&
              request.resource.data[key].size() >= minLen &&
              !('' in request.resource.data[key]) &&
              !(null in request.resource.data[key]);
    }

    function optionalArrayKey(key, minLen, maxLen) {
      return (key in request.resource.data &&
          request.resource.data[key] != null) ? 
        requiredArrayKey(key, minLen, maxLen) : true;
    }

    function requiredObjectKey(key) {
      return request.resource.data[key] is map;
    }

    function requiredCreatedAtKey() {
      // if it exists already in existing doc, we should not change the value
      let isServerTimestamp = request.resource.data.createdAt == request.time;
      return isNewDoc() ? isServerTimestamp : (request.resource.data.createdAt == resource.data.createdAt);
    }

    match /users/{userId} {
      allow read;

      allow update: if 
        request.auth != null && 
        request.auth.uid == userId &&
        assertKeys(['displayName', 'email', 'photoURL', 'bio', 'defaultWorkspaceId']) &&
        requiredStringKey('displayName', 1, 50) &&
        optionalStringKey('email', 50) &&
        optionalStringKey('photoURL', 280) &&
        optionalStringKey('bio', 280) &&
        optionalStringKey('defaultWorkspaceId', 30);
    }

    match /templates/{templateId} {
      allow read;

      allow write: if 
        request.auth != null &&
        assertKeys(['name', 'creatorId', 'workspaceId', 'activities', 'notes', 'createdAt']) &&
        requiredStringKey('name', 1, 50) &&
        requiredStringKey('creatorId', 1, 30) &&
        requiredStringKey('workspaceId', 1, 30) &&
        requiredCreatedAtKey() &&

        // array of step objects that define the call
        requiredArrayKey('activities', 0, 100) &&

        // presenter notes, in markdown format
        optionalStringKey('notes', 50000) &&

        // when creating, make sure creatorId is set
        // when editing, make sure only creator can edit
        (isNewDoc() ? 
          (request.resource.data.creatorId == request.auth.uid) : 
          (resource.data.creatorId == request.auth.uid));
    } // match template

    match /calls/{callId} {
      allow read;

      allow write: if
        request.auth != null &&
        assertKeys(['templateId', 'creatorId', 'state', 'currentStep', 'stepData', 'notes', 'createdAt']) &&
        requiredStringKey('templateId', 1, 30) &&
        requiredStringKey('creatorId', 1, 30) &&
        requiredEnumKey('state', ['started', 'finished']) &&
        requiredCreatedAtKey() &&
        requiredIntKey('currentStep', 0, 100) &&

        // map of step IDs and the metadata for each step
        requiredObjectKey('stepData') &&

        // meeting notes, in markdown format
        optionalStringKey('notes', 50000);
    } // match call

    match /presentations/{presentationId} {
      allow read;

      allow write: if
        request.auth != null &&
        assertKeys(['name', 'creatorId', 'workspaceId', 'slides', 'isProcessed', 'createdAt']) &&
        requiredStringKey('name', 1, 50) &&
        requiredStringKey('creatorId', 1, 30) &&
        requiredStringKey('workspaceId', 1, 30) &&
        // array of URLs or path in bucket
        requiredArrayKey('slides', 1, 1000) &&
        // set to true when all slides have been processed
        requiredBoolKey('isProcessed') &&
        requiredCreatedAtKey() &&
        // when creating, creatorId should be the current user, 
        // when editing, make sure it's the same user
        (isNewDoc() ?
          (request.resource.data.creatorId == request.auth.uid) : 
          (resource.data.creatorId == request.auth.uid));
    }

    // for members collectionGroup queries
    // only allow collection group queries for members to get their own workspaces
    match /{path=**}/members/{memberId} {
      allow read: if 
        request.auth != null &&
        resource.data.memberId == request.auth.uid;

    }

    match /workspaces/{workspaceId} {

      function currentMember() {
        return get(/databases/$(database)/documents/workspaces/$(workspaceId)/members/$(request.auth.uid)).data;
      }

      allow read;

      allow write: if
        request.auth != null &&
        assertKeys(['name', 'logoURL', 'primaryColor', 'backgroundColor', 'createdAt']) &&
        requiredStringKey('name', 1, 50) &&
        optionalStringKey('logoURL', 280) &&
        optionalStringKey('primaryColor', 10) &&
        optionalStringKey('backgroundColor', 10) &&
        requiredCreatedAtKey() &&
        // make sure member doc is also created
        // only workspace owners can update
        (isNewDoc() ? 
          getAfter(/databases/$(database)/documents/workspaces/$(request.resource.id)/members/$(request.auth.uid)).data.role == 'owner' : 
          currentMember().role == 'owner');

      match /members/{memberId} {
        allow read: if
          request.auth != null;

        allow write: if
          request.auth != null &&
          assertKeys(['memberId', 'role', 'createdAt']) &&
          // have explicit memberId for collectionGroup indexing
          requiredStringKey('memberId', 1, 30) &&
          requiredEnumKey('role', ['owner', 'member']) &&
          requiredCreatedAtKey() &&

          // make sure memberId is always equal to the docId
          request.resource.data.memberId == memberId &&

          // if adding self, make sure its a new workspace (should not exist)
          // if adding others, make sure only admins can add another admin
          (request.auth.uid == memberId ? 
            !exists(/databases/$(database)/documents/workspaces/$(workspaceId)) : 
          currentMember().role in ['owner']);
      }
    } // match workspace 

  } // match database
} // service firestore
