rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // FOR DATA LENGTH:
    // id should be 24
    // short text like names should be 50
    // URLs should be 280
    // short descriptions should be 280

    function currentUser() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function getUser(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    // ensures that only the input list of keys are used, and no others
    function assertKeys(keys) {
      return request.resource.data.keys().toSet().hasOnly(keys.toSet());
    }

    function isNewDoc() {
      return resource == null;
    }

    function requiredStringKey(key, maxLen) {
      return request.resource.data[key] is string && 
              request.resource.data[key].size() > 0 &&
              request.resource.data[key].size() <= maxLen;
    }

    function optionalStringKey(key, maxLen) {
      return key in request.resource.data ? requiredStringKey(key, maxLen) : true;
    }

    function requiredIntKey(key, min, max) {
      return request.resource.data[key] is int &&
              request.resoure.data[key] >= min &&
              request.resource.data[key] < max;
    }

    function optionalIntKey(key, min, max) {
      return key in request.resource.data ? requiredIntKey(key, min, max) : true;
    }

    function requiredBoolKey(key) {
      return request.resource.data[key] is bool;
    }

    function requiredEnumKey(key, enums) {
      let item = request.resource.data[key];
      return requiredStringKey(key, 10) &&
              item in enums.toSet();
    }

    function requiredTimeKey(key) {
      return request.resource.data[key] is timestamp;
    }

    function optionalTimeKey(key) {
      return key in request.resource.data ? requiredTimeKey(key) : true;
    }

    function requiredArrayKey(key, maxLen) {
      return request.resource.data[key] is list &&
              request.resource.data[key].size() <= maxLen &&
              !('' in request.resource.data[key]) &&
              !(null in request.resource.data[key]);
    }

    function optionalArrayKey(key, maxLen) {
      return key in request.resource.data ? requiredArrayKey(key, maxLen) : true;
    }

    function requiredObjectKey(key) {
      return request.resource.data[key] is map;
    }

    function requiredCreatedAtKey() {
      // if it exists already in existing doc, we should not change the value
      let isServerTimestamp = request.resource.data.createdAt == request.time;
      return isNewDoc() ? isServerTimestamp : (request.resource.data.createdAt == resource.data.createdAt);
    }

    match /users/{userId} {
      allow read;

      allow update: if 
        request.auth != null && 
        request.auth.uid == userId &&
        assertKeys(['networkId', 'bio', 'createdAt']) &&
        optionalStringKey('networkId', 24) &&
        optionalStringKey('bio', 280) &&
        requiredCreatedAtKey();
    }

    match /calls/{callId} {
      allow read;

      allow write: if 
        request.auth != null &&
        assertKeys(['name', 'state', 'networkId', 'users', 'guests', 'guestEmails', 'startTime', 'durationMin', 'presentationId', 'noteId', 'chatId', 'transcriptId', 'createdAt']) &&
        requiredStringKey('name', 50) &&
        requiredEnumKey('state', ['pre', 'started', 'finished']) &&
        optionalStringKey('networkId', 24) &&

        // list of users who can manage and start the call
        requiredArrayKey('users', 50) &&
        // list of users who are the guests in the call
        optionalArrayKey('guests', 50) &&
        // emails of guests who have access to this call
        // note that this array should be converted to uids in guest array post create
        optionalArrayKey('guestEmails', 50) &&

        // presentation scheduling
        optionalTimeKey('startTime') &&
        optionalIntKey('durationMin', 0, 24*60) &&

        // set if have presentation attachment
        optionalStringKey('presentationId', 24) &&
        // set if have note attachment
        optionalStringKey('noteId', 24) &&
        // set if have chat attachment
        optionalStringKey('chatId', 24) &&
        // set once transcrit is ready
        optionalStringKey('transcriptId', 24) &&
        requiredCreatedAtKey() &&

        // when creating, users should contain at least one user which is the 
        // current user. When editing, existing doc must contain current user
        (isNewDoc() ? 
         (request.resource.data.users.size() >= 1 &&
          request.resource.data.users.hasAny([request.auth.uid])) : 
         (resource.data.users.hasAny([request.auth.uid])));

      match /notes/{noteId} {
        allow read;

        allow write: if
          assertKeys(['text']) &&
          requiredStringKey('text', 50000);
      }
    } // match call

    match /presentations/{presentationId} {
      allow read;

      allow write: if
        assertKeys(['fileId']) &&
        requiredStringKey('fileId', 24);
    }

    match /networks/{networkId} {

      function currentAdmin() {
        return get(/databases/$(database)/documents/networks/$(networkId)/admins/$(request.auth.uid)).data;
      }

      allow read;

      allow update: if
        request.auth != null &&
        assertKeys(['name', 'logoURL', 'primaryColor', 'createdAt']) &&
        requiredStringKey('name', 50) &&
        optionalStringKey('logoURL', 280) &&
        optionalStringKey('primaryColor', 10) &&
        requiredCreatedAtKey() &&
        // only network owners can update
        currentAdmin().role == 'owner';

      match /admins/{adminId} {
        allow read: if
          request.auth != null &&
          // make sure only users in the same network can read admin list
          exists(/database/$(database)/documents/networks/$(networkId)/users/$(request.auth.uid));

        allow write: if
          assertKeys(['role', 'createdAt']) &&
          requiredStringKey('role', 10) &&
          requiredCreatedAtKey() &&
          // make sure only owners can create another admin
          currentAdmin().role == 'owner' &&
          // make sure this admin is also an user and belongs to same network
          getUser(adminId).networkId == networkId;
      }
    } // match network

  } // match database
} // service firestore
